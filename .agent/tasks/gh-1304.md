# GH-1304

**Created:** 2026-02-15

## Problem

GitHub Issue #1304: fix(autopilot): cache GetPR, add API failure escalation, dynamic CI poll interval

## Problem

Autopilot CI polling has 3 inefficiencies (remaining work from GH-531):

1. **Redundant GetPullRequest calls** — `processAllPRs()` calls `checkExternalMergeOrClose()` which fetches the PR (controller.go:1296), then `ProcessPR() → handleWaitingCI()` fetches the **same PR again** (controller.go:363). That's 2 GetPR + 1 ListCheckRuns = **3 API calls per tick per waiting PR**.
2. **Silent API failure swallowing** — if `GetPullRequest` fails in `handleWaitingCI()` (line 365-369), the error is logged but swallowed. No escalation after repeated failures. PR stays stuck in `waiting_ci` indefinitely.
3. **Fixed 30s poll interval** — `CIPollInterval` is static (controller.go:1242). Even when no PRs are in `StageWaitingCI`, the controller polls every 30s. When CI is actively running, 30s detection delay is too slow.

## Solution

### 1. Cache GetPullRequest in processAllPRs loop

In `processAllPRs()` (controller.go:1256-1291), fetch PR **once** at the top of the loop and pass to both consumers:

```go
func (c *Controller) processAllPRs(ctx context.Context) {
    prs := c.GetActivePRs()
    c.metrics.UpdateActivePRs(prs)

    for _, pr := range prs {
        // Fetch once, use twice
        ghPR, err := c.ghClient.GetPullRequest(ctx, c.owner, c.repo, pr.PRNumber)
        if err != nil {
            c.log.Warn("failed to fetch PR", "pr", pr.PRNumber, "error", err)
            continue
        }

        if c.checkExternalMergeOrClose(ctx, pr, ghPR) {
            continue
        }

        if err := c.ProcessPR(ctx, pr.PRNumber, ghPR); err != nil {
            continue
        }
    }
}
```

Update signatures:
- `checkExternalMergeOrClose(ctx, prState, ghPR)` — accept `*github.PullRequest`, remove internal fetch
- `ProcessPR(ctx, prNumber, ghPR)` — pass cached PR through to handlers
- `handleWaitingCI(ctx, prState, ghPR)` — accept optional `*github.PullRequest`, skip fetch if provided
- `handlePRCreated(ctx, prState, ghPR)` — accept optional `*github.PullRequest`

### 2. Add consecutive API failure counter

Add field to `PRState` in `internal/autopilot/types.go`:

```go
type PRState struct {
    // ... existing fields ...
    ConsecutiveAPIFailures int // Consecutive CI check API failures
}
```

In `handleWaitingCI()`, after `ciMonitor.CheckCI()` call:
- On error: increment `ConsecutiveAPIFailures`
- If `>= 5` consecutive failures (2.5 min at 30s interval): transition to `StageFailed` with descriptive error
- On success: reset `ConsecutiveAPIFailures = 0`

```go
status, err := c.ciMonitor.CheckCI(ctx, sha)
if err != nil {
    prState.ConsecutiveAPIFailures++
    c.log.Warn("CI check failed",
        "pr", prState.PRNumber,
        "consecutive_failures", prState.ConsecutiveAPIFailures,
        "error", err)
    if prState.ConsecutiveAPIFailures >= 5 {
        prState.Stage = StageFailed
        prState.Error = fmt.Sprintf("CI check API failed %d consecutive times: %v",
            prState.ConsecutiveAPIFailures, err)
    }
    return nil
}
prState.ConsecutiveAPIFailures = 0
```

### 3. Dynamic CI poll interval

In `Run()` method (controller.go:1231-1254), adjust ticker based on active PR states:

```go
func (c *Controller) Run(ctx context.Context) {
    basePollInterval := c.config.CIPollInterval
    fastPollInterval := 10 * time.Second
    idlePollInterval := 60 * time.Second

    ticker := time.NewTicker(basePollInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            c.processAllPRs(ctx)

            // Adjust interval based on state
            newInterval := idlePollInterval
            for _, pr := range c.GetActivePRs() {
                if pr.Stage == StageWaitingCI || pr.Stage == StagePRCreated {
                    newInterval = fastPollInterval
                    break
                }
            }
            if newInterval != basePollInterval {
                ticker.Reset(newInterval)
                basePollInterval = newInterval
            }
        }
    }
}
```

Intervals:
- **10s**: Any PR in `StageWaitingCI` or `StagePRCreated` (fast detection)
- **60s**: All PRs in other states or no active PRs (save API quota)

## Files to modify

| File | Change |
|------|--------|
| `internal/autopilot/controller.go` | Cache PR in `processAllPRs()`, update `checkExternalMergeOrClose` / `ProcessPR` / `handleWaitingCI` / `handlePRCreated` signatures, add failure counter in `handleWaitingCI`, dynamic interval in `Run()` |
| `internal/autopilot/types.go` | Add `ConsecutiveAPIFailures int` to `PRState` |

## Tests

- Verify cached PR reduces `GetPullRequest` mock call count from 2 to 1 per tick per waiting PR
- Test consecutive failure escalation: 5 failures → `StageFailed` with descriptive error
- Test failure counter reset on success
- Test dynamic poll interval: ticker resets to 10s when PR enters WaitingCI, back to 60s when resolved
- Existing controller tests must still pass (update signatures in test helpers)

## Acceptance Criteria

- [ ] `GetPullRequest` called exactly once per PR per poll cycle (not twice)
- [ ] 5 consecutive `CheckCI` API failures → PR transitions to `StageFailed`
- [ ] Poll interval drops to 10s when any PR is in `WaitingCI`
- [ ] Poll interval increases to 60s when no PRs need CI monitoring
- [ ] All existing autopilot controller tests pass
- [ ] New tests for failure counter and dynamic interval

## Planned Steps (execute all in sequence)

1. **Cache GetPR, add API failure escalation, and dynamic CI poll interval in autopilot package** — All changes are within `internal/autopilot/`. Modify `types.go` to add `ConsecutiveAPIFailures int` to `PRState`. In `controller.go`: refactor `processAllPRs()` to fetch each PR once and pass the cached `*github.PullRequest` to `checkExternalMergeOrClose()` and `ProcessPR()`; update the signatures of `checkExternalMergeOrClose`, `ProcessPR`, `handleWaitingCI`, and `handlePRCreated` to accept an optional `*github.PullRequest` parameter (skip internal fetch when provided); add consecutive failure counting in `handleWaitingCI()` that transitions to `StageFailed` after 5 consecutive `CheckCI` errors and resets on success; refactor `Run()` to use dynamic poll intervals (10s when any PR is in `StageWaitingCI`/`StagePRCreated`, 60s otherwise). Update `controller_test.go` and `controller_integration_test.go` to match new signatures, add tests for: single `GetPullRequest` call per PR per cycle, failure counter escalation at threshold, failure counter reset on success, and dynamic ticker interval adjustment. All existing tests must continue to pass.


## Acceptance Criteria

