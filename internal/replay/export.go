package replay

import (
	"fmt"
	"sort"
	"strings"
	"time"
)

// ExportHTMLReport generates a comprehensive HTML report with analysis
func ExportHTMLReport(recording *Recording, events []*StreamEvent, report *AnalysisReport) (string, error) {
	var sb strings.Builder

	sb.WriteString("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n")
	sb.WriteString("<meta charset=\"UTF-8\">\n")
	sb.WriteString("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n")
	sb.WriteString(fmt.Sprintf("<title>Execution Report: %s</title>\n", recording.ID))
	sb.WriteString("<style>\n")
	sb.WriteString(htmlReportStyles())
	sb.WriteString("</style>\n</head>\n<body>\n")

	// Header section
	sb.WriteString(renderHTMLHeader(recording))

	// Summary cards
	sb.WriteString(renderHTMLSummary(recording))

	// Token breakdown
	if report != nil && recording.TokenUsage != nil {
		sb.WriteString(renderHTMLTokenBreakdown(report))
	}

	// Phase timing chart
	if report != nil && len(report.PhaseAnalysis) > 0 {
		sb.WriteString(renderHTMLPhaseChart(report, recording.Duration))
	}

	// Tool usage
	if report != nil && len(report.ToolUsage) > 0 {
		sb.WriteString(renderHTMLToolUsage(report))
	}

	// Errors section
	if report != nil && len(report.Errors) > 0 {
		sb.WriteString(renderHTMLErrors(report))
	}

	// Timeline
	sb.WriteString(renderHTMLTimeline(events))

	// Footer
	sb.WriteString("<div class=\"footer\">\n")
	sb.WriteString(fmt.Sprintf("<p>Generated by Pilot v0.2.0 on %s</p>\n", time.Now().Format("2006-01-02 15:04:05")))
	sb.WriteString("</div>\n")

	sb.WriteString("</body>\n</html>")

	return sb.String(), nil
}

func htmlReportStyles() string {
	return `
:root {
  --bg-primary: #0d1117;
  --bg-secondary: #161b22;
  --bg-tertiary: #21262d;
  --text-primary: #e6edf3;
  --text-secondary: #8b949e;
  --text-muted: #6e7681;
  --border-color: #30363d;
  --accent-blue: #58a6ff;
  --accent-green: #3fb950;
  --accent-yellow: #d29922;
  --accent-red: #f85149;
  --accent-purple: #a371f7;
}

* { box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  margin: 0;
  padding: 20px;
  line-height: 1.5;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
}

.header {
  background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
  padding: 32px;
  border-radius: 12px;
  margin-bottom: 24px;
  border: 1px solid var(--border-color);
}

.header h1 {
  margin: 0 0 8px 0;
  font-size: 28px;
  color: var(--text-primary);
}

.header .subtitle {
  color: var(--text-secondary);
  font-size: 16px;
}

.status-badge {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 13px;
  font-weight: 500;
  margin-left: 12px;
}

.status-completed { background: rgba(63, 185, 80, 0.2); color: var(--accent-green); }
.status-failed { background: rgba(248, 81, 73, 0.2); color: var(--accent-red); }
.status-cancelled { background: rgba(210, 153, 34, 0.2); color: var(--accent-yellow); }

.summary-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
}

.summary-card {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 20px;
}

.summary-card .label {
  color: var(--text-secondary);
  font-size: 13px;
  margin-bottom: 4px;
}

.summary-card .value {
  font-size: 24px;
  font-weight: 600;
  color: var(--text-primary);
}

.summary-card .subvalue {
  color: var(--text-muted);
  font-size: 13px;
}

.section {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 24px;
  margin-bottom: 24px;
}

.section h2 {
  margin: 0 0 20px 0;
  font-size: 18px;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  gap: 8px;
}

.section h2 .icon { font-size: 20px; }

.chart-bar {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
}

.chart-label {
  width: 120px;
  font-size: 14px;
  color: var(--text-secondary);
}

.chart-bar-container {
  flex: 1;
  height: 24px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  overflow: hidden;
  margin: 0 12px;
}

.chart-bar-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.3s ease;
}

.chart-value {
  width: 80px;
  text-align: right;
  font-size: 13px;
  color: var(--text-muted);
}

.phase-research { background: var(--accent-blue); }
.phase-implementing { background: var(--accent-green); }
.phase-verifying { background: var(--accent-yellow); }
.phase-completing { background: var(--accent-purple); }
.phase-init { background: var(--text-muted); }

.tool-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 12px;
}

.tool-card {
  background: var(--bg-tertiary);
  border-radius: 6px;
  padding: 16px;
}

.tool-name {
  font-weight: 500;
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.tool-stats {
  font-size: 13px;
  color: var(--text-secondary);
}

.error-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.error-item {
  background: rgba(248, 81, 73, 0.1);
  border: 1px solid rgba(248, 81, 73, 0.3);
  border-radius: 6px;
  padding: 16px;
}

.error-meta {
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.error-message {
  color: var(--accent-red);
  font-family: 'SFMono-Regular', Consolas, monospace;
  font-size: 13px;
}

.timeline {
  max-height: 600px;
  overflow-y: auto;
  border: 1px solid var(--border-color);
  border-radius: 6px;
}

.timeline-event {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: flex-start;
  gap: 12px;
}

.timeline-event:last-child { border-bottom: none; }

.timeline-event:hover {
  background: var(--bg-tertiary);
}

.timeline-time {
  font-size: 12px;
  color: var(--text-muted);
  font-family: monospace;
  white-space: nowrap;
}

.timeline-seq {
  font-size: 11px;
  color: var(--text-muted);
  width: 40px;
}

.timeline-icon { font-size: 16px; }

.timeline-content {
  flex: 1;
  font-size: 14px;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
}

.timeline-event.tool .timeline-content { color: var(--accent-blue); }
.timeline-event.text .timeline-content { color: var(--text-primary); }
.timeline-event.error .timeline-content { color: var(--accent-red); }
.timeline-event.result .timeline-content { color: var(--accent-green); }

.footer {
  text-align: center;
  padding: 24px;
  color: var(--text-muted);
  font-size: 13px;
}
`
}

func renderHTMLHeader(recording *Recording) string {
	var sb strings.Builder

	statusClass := "status-completed"
	switch recording.Status {
	case "failed":
		statusClass = "status-failed"
	case "cancelled":
		statusClass = "status-cancelled"
	}

	sb.WriteString("<div class=\"container\">\n")
	sb.WriteString("<div class=\"header\">\n")
	sb.WriteString(fmt.Sprintf("<h1>üìπ %s <span class=\"status-badge %s\">%s</span></h1>\n",
		recording.ID, statusClass, recording.Status))
	sb.WriteString(fmt.Sprintf("<div class=\"subtitle\">Task: %s</div>\n", escapeHTML(recording.TaskID)))
	sb.WriteString(fmt.Sprintf("<div class=\"subtitle\">Project: %s</div>\n", escapeHTML(recording.ProjectPath)))
	sb.WriteString(fmt.Sprintf("<div class=\"subtitle\">Executed: %s</div>\n",
		recording.StartTime.Format("January 2, 2006 at 15:04:05")))
	sb.WriteString("</div>\n")

	return sb.String()
}

func renderHTMLSummary(recording *Recording) string {
	var sb strings.Builder

	sb.WriteString("<div class=\"summary-grid\">\n")

	// Duration
	sb.WriteString("<div class=\"summary-card\">\n")
	sb.WriteString("<div class=\"label\">Duration</div>\n")
	sb.WriteString(fmt.Sprintf("<div class=\"value\">%s</div>\n", formatDuration(recording.Duration)))
	sb.WriteString("</div>\n")

	// Events
	sb.WriteString("<div class=\"summary-card\">\n")
	sb.WriteString("<div class=\"label\">Total Events</div>\n")
	sb.WriteString(fmt.Sprintf("<div class=\"value\">%d</div>\n", recording.EventCount))
	sb.WriteString("</div>\n")

	// Tokens
	if recording.TokenUsage != nil {
		sb.WriteString("<div class=\"summary-card\">\n")
		sb.WriteString("<div class=\"label\">Total Tokens</div>\n")
		sb.WriteString(fmt.Sprintf("<div class=\"value\">%s</div>\n", formatNumber(recording.TokenUsage.TotalTokens)))
		sb.WriteString(fmt.Sprintf("<div class=\"subvalue\">%s in / %s out</div>\n",
			formatNumber(recording.TokenUsage.InputTokens),
			formatNumber(recording.TokenUsage.OutputTokens)))
		sb.WriteString("</div>\n")

		// Cost
		sb.WriteString("<div class=\"summary-card\">\n")
		sb.WriteString("<div class=\"label\">Estimated Cost</div>\n")
		sb.WriteString(fmt.Sprintf("<div class=\"value\">$%.4f</div>\n", recording.TokenUsage.EstimatedCostUSD))
		sb.WriteString("</div>\n")
	}

	// Model
	if recording.Metadata != nil && recording.Metadata.ModelName != "" {
		sb.WriteString("<div class=\"summary-card\">\n")
		sb.WriteString("<div class=\"label\">Model</div>\n")
		sb.WriteString(fmt.Sprintf("<div class=\"value\" style=\"font-size: 16px;\">%s</div>\n",
			escapeHTML(recording.Metadata.ModelName)))
		sb.WriteString("</div>\n")
	}

	// Navigator
	if recording.Metadata != nil && recording.Metadata.HasNavigator {
		sb.WriteString("<div class=\"summary-card\">\n")
		sb.WriteString("<div class=\"label\">Navigator</div>\n")
		sb.WriteString("<div class=\"value\" style=\"color: var(--accent-green);\">‚úì Enabled</div>\n")
		sb.WriteString("</div>\n")
	}

	sb.WriteString("</div>\n")

	return sb.String()
}

func renderHTMLTokenBreakdown(report *AnalysisReport) string {
	var sb strings.Builder

	sb.WriteString("<div class=\"section\">\n")
	sb.WriteString("<h2><span class=\"icon\">üìä</span> Token Breakdown</h2>\n")

	// By phase
	if len(report.TokenBreakdown.ByPhase) > 0 {
		sb.WriteString("<h3 style=\"margin-bottom: 12px; color: var(--text-secondary);\">By Phase</h3>\n")

		total := report.Recording.TokenUsage.TotalTokens
		for phase, usage := range report.TokenBreakdown.ByPhase {
			pct := float64(usage.TotalTokens) / float64(total) * 100
			sb.WriteString("<div class=\"chart-bar\">\n")
			sb.WriteString(fmt.Sprintf("<div class=\"chart-label\">%s</div>\n", phase))
			sb.WriteString("<div class=\"chart-bar-container\">\n")
			sb.WriteString(fmt.Sprintf("<div class=\"chart-bar-fill phase-%s\" style=\"width: %.1f%%;\"></div>\n",
				strings.ToLower(phase), pct))
			sb.WriteString("</div>\n")
			sb.WriteString(fmt.Sprintf("<div class=\"chart-value\">%s (%.1f%%)</div>\n",
				formatNumber(usage.TotalTokens), pct))
			sb.WriteString("</div>\n")
		}
	}

	sb.WriteString("</div>\n")

	return sb.String()
}

func renderHTMLPhaseChart(report *AnalysisReport, totalDuration time.Duration) string {
	var sb strings.Builder

	sb.WriteString("<div class=\"section\">\n")
	sb.WriteString("<h2><span class=\"icon\">‚è±Ô∏è</span> Phase Timing</h2>\n")

	for _, phase := range report.PhaseAnalysis {
		pct := phase.Percentage
		sb.WriteString("<div class=\"chart-bar\">\n")
		sb.WriteString(fmt.Sprintf("<div class=\"chart-label\">%s</div>\n", phase.Phase))
		sb.WriteString("<div class=\"chart-bar-container\">\n")
		phaseClass := strings.ToLower(strings.ReplaceAll(phase.Phase, " ", "-"))
		sb.WriteString(fmt.Sprintf("<div class=\"chart-bar-fill phase-%s\" style=\"width: %.1f%%;\"></div>\n",
			phaseClass, pct))
		sb.WriteString("</div>\n")
		sb.WriteString(fmt.Sprintf("<div class=\"chart-value\">%s (%.1f%%)</div>\n",
			formatDuration(phase.Duration), pct))
		sb.WriteString("</div>\n")
	}

	sb.WriteString("</div>\n")

	return sb.String()
}

func renderHTMLToolUsage(report *AnalysisReport) string {
	var sb strings.Builder

	sb.WriteString("<div class=\"section\">\n")
	sb.WriteString("<h2><span class=\"icon\">üîß</span> Tool Usage</h2>\n")
	sb.WriteString("<div class=\"tool-grid\">\n")

	// Sort by count
	tools := make([]ToolUsageStats, len(report.ToolUsage))
	copy(tools, report.ToolUsage)
	sort.Slice(tools, func(i, j int) bool {
		return tools[i].Count > tools[j].Count
	})

	for _, tool := range tools {
		icon := getToolIcon(tool.Tool)
		errorStr := ""
		if tool.ErrorCount > 0 {
			errorStr = fmt.Sprintf(" <span style=\"color: var(--accent-red);\">(%d errors)</span>", tool.ErrorCount)
		}

		sb.WriteString("<div class=\"tool-card\">\n")
		sb.WriteString(fmt.Sprintf("<div class=\"tool-name\">%s %s</div>\n", icon, tool.Tool))
		sb.WriteString(fmt.Sprintf("<div class=\"tool-stats\">%d calls%s</div>\n", tool.Count, errorStr))
		if tool.InputTokens > 0 || tool.OutputTokens > 0 {
			sb.WriteString(fmt.Sprintf("<div class=\"tool-stats\">%s tokens</div>\n",
				formatNumber(tool.InputTokens+tool.OutputTokens)))
		}
		sb.WriteString("</div>\n")
	}

	sb.WriteString("</div>\n")
	sb.WriteString("</div>\n")

	return sb.String()
}

func renderHTMLErrors(report *AnalysisReport) string {
	var sb strings.Builder

	sb.WriteString("<div class=\"section\">\n")
	sb.WriteString(fmt.Sprintf("<h2><span class=\"icon\">‚ùå</span> Errors (%d)</h2>\n", len(report.Errors)))
	sb.WriteString("<div class=\"error-list\">\n")

	for _, err := range report.Errors {
		sb.WriteString("<div class=\"error-item\">\n")
		sb.WriteString(fmt.Sprintf("<div class=\"error-meta\">#%d at %s | Phase: %s | Tool: %s</div>\n",
			err.Sequence, err.Timestamp.Format("15:04:05"), err.Phase, err.Tool))
		sb.WriteString(fmt.Sprintf("<div class=\"error-message\">%s</div>\n", escapeHTML(err.Message)))
		sb.WriteString("</div>\n")
	}

	sb.WriteString("</div>\n")
	sb.WriteString("</div>\n")

	return sb.String()
}

func renderHTMLTimeline(events []*StreamEvent) string {
	var sb strings.Builder

	sb.WriteString("<div class=\"section\">\n")
	sb.WriteString(fmt.Sprintf("<h2><span class=\"icon\">üìú</span> Execution Timeline (%d events)</h2>\n", len(events)))
	sb.WriteString("<div class=\"timeline\">\n")

	for _, event := range events {
		class := "timeline-event"
		icon := "üìù"

		if event.Parsed != nil {
			p := event.Parsed
			if p.IsError {
				class += " error"
				icon = "‚ùå"
			} else if p.ToolName != "" {
				class += " tool"
				icon = getToolIcon(p.ToolName)
			} else if p.Text != "" {
				class += " text"
				icon = "üí¨"
			} else if p.Type == "result" {
				class += " result"
				icon = "‚úÖ"
			} else if p.Type == "system" {
				icon = "‚öôÔ∏è"
			}
		}

		content := formatEventForTimeline(event)

		sb.WriteString(fmt.Sprintf("<div class=\"%s\">\n", class))
		sb.WriteString(fmt.Sprintf("<span class=\"timeline-time\">%s</span>\n",
			event.Timestamp.Format("15:04:05.000")))
		sb.WriteString(fmt.Sprintf("<span class=\"timeline-seq\">#%d</span>\n", event.Sequence))
		sb.WriteString(fmt.Sprintf("<span class=\"timeline-icon\">%s</span>\n", icon))
		sb.WriteString(fmt.Sprintf("<span class=\"timeline-content\">%s</span>\n", escapeHTML(content)))
		sb.WriteString("</div>\n")
	}

	sb.WriteString("</div>\n")
	sb.WriteString("</div>\n")
	sb.WriteString("</div>\n") // Close container

	return sb.String()
}

func formatEventForTimeline(event *StreamEvent) string {
	if event.Parsed == nil {
		return fmt.Sprintf("(%s)", event.Type)
	}

	p := event.Parsed

	switch p.Type {
	case "system":
		if p.Subtype == "init" {
			return "System initialized"
		}
		return fmt.Sprintf("System: %s", p.Subtype)

	case "assistant":
		if p.ToolName != "" {
			detail := formatToolDetail(p)
			if detail != "" {
				return fmt.Sprintf("%s: %s", p.ToolName, truncate(detail, 100))
			}
			return p.ToolName
		}
		if p.Text != "" {
			return truncate(strings.ReplaceAll(p.Text, "\n", " "), 150)
		}
		return "(assistant)"

	case "user":
		return "Tool result received"

	case "result":
		if p.IsError {
			return fmt.Sprintf("Error: %s", truncate(p.Result, 100))
		}
		if p.InputTokens > 0 || p.OutputTokens > 0 {
			return fmt.Sprintf("Completed (%d in, %d out tokens)", p.InputTokens, p.OutputTokens)
		}
		return "Completed"

	default:
		return fmt.Sprintf("(%s)", p.Type)
	}
}

// ExportToMarkdown exports a recording to Markdown format
func ExportToMarkdown(recording *Recording, events []*StreamEvent, report *AnalysisReport) (string, error) {
	var sb strings.Builder

	// Header
	sb.WriteString(fmt.Sprintf("# Execution Recording: %s\n\n", recording.ID))

	// Status badge
	statusIcon := "‚úÖ"
	switch recording.Status {
	case "failed":
		statusIcon = "‚ùå"
	case "cancelled":
		statusIcon = "‚ö†Ô∏è"
	}
	sb.WriteString(fmt.Sprintf("**Status:** %s %s\n\n", statusIcon, recording.Status))

	// Metadata table
	sb.WriteString("## Summary\n\n")
	sb.WriteString("| Property | Value |\n")
	sb.WriteString("|----------|-------|\n")
	sb.WriteString(fmt.Sprintf("| Task ID | %s |\n", recording.TaskID))
	sb.WriteString(fmt.Sprintf("| Project | %s |\n", recording.ProjectPath))
	sb.WriteString(fmt.Sprintf("| Duration | %s |\n", formatDuration(recording.Duration)))
	sb.WriteString(fmt.Sprintf("| Events | %d |\n", recording.EventCount))
	sb.WriteString(fmt.Sprintf("| Started | %s |\n", recording.StartTime.Format("2006-01-02 15:04:05")))
	sb.WriteString(fmt.Sprintf("| Ended | %s |\n", recording.EndTime.Format("2006-01-02 15:04:05")))

	if recording.Metadata != nil {
		if recording.Metadata.Branch != "" {
			sb.WriteString(fmt.Sprintf("| Branch | `%s` |\n", recording.Metadata.Branch))
		}
		if recording.Metadata.CommitSHA != "" {
			sb.WriteString(fmt.Sprintf("| Commit | `%s` |\n", recording.Metadata.CommitSHA))
		}
		if recording.Metadata.PRUrl != "" {
			sb.WriteString(fmt.Sprintf("| PR | %s |\n", recording.Metadata.PRUrl))
		}
		if recording.Metadata.ModelName != "" {
			sb.WriteString(fmt.Sprintf("| Model | %s |\n", recording.Metadata.ModelName))
		}
		sb.WriteString(fmt.Sprintf("| Navigator | %v |\n", recording.Metadata.HasNavigator))
	}
	sb.WriteString("\n")

	// Token Usage
	if recording.TokenUsage != nil {
		sb.WriteString("## Token Usage\n\n")
		sb.WriteString(fmt.Sprintf("- **Input:** %s tokens\n", formatNumber(recording.TokenUsage.InputTokens)))
		sb.WriteString(fmt.Sprintf("- **Output:** %s tokens\n", formatNumber(recording.TokenUsage.OutputTokens)))
		sb.WriteString(fmt.Sprintf("- **Total:** %s tokens\n", formatNumber(recording.TokenUsage.TotalTokens)))
		sb.WriteString(fmt.Sprintf("- **Estimated Cost:** $%.4f\n", recording.TokenUsage.EstimatedCostUSD))
		sb.WriteString("\n")
	}

	// Phase Timing
	if report != nil && len(report.PhaseAnalysis) > 0 {
		sb.WriteString("## Phase Timing\n\n")
		sb.WriteString("| Phase | Duration | Percentage | Events |\n")
		sb.WriteString("|-------|----------|------------|--------|\n")
		for _, phase := range report.PhaseAnalysis {
			sb.WriteString(fmt.Sprintf("| %s | %s | %.1f%% | %d |\n",
				phase.Phase, formatDuration(phase.Duration), phase.Percentage, phase.EventCount))
		}
		sb.WriteString("\n")
	}

	// Tool Usage
	if report != nil && len(report.ToolUsage) > 0 {
		sb.WriteString("## Tool Usage\n\n")
		sb.WriteString("| Tool | Calls | Errors | Tokens |\n")
		sb.WriteString("|------|-------|--------|--------|\n")
		for _, tool := range report.ToolUsage {
			tokens := tool.InputTokens + tool.OutputTokens
			sb.WriteString(fmt.Sprintf("| %s | %d | %d | %s |\n",
				tool.Tool, tool.Count, tool.ErrorCount, formatNumber(tokens)))
		}
		sb.WriteString("\n")
	}

	// Errors
	if report != nil && len(report.Errors) > 0 {
		sb.WriteString("## Errors\n\n")
		for i, err := range report.Errors {
			sb.WriteString(fmt.Sprintf("### Error %d\n\n", i+1))
			sb.WriteString(fmt.Sprintf("- **Time:** %s (#%d)\n", err.Timestamp.Format("15:04:05"), err.Sequence))
			sb.WriteString(fmt.Sprintf("- **Phase:** %s\n", err.Phase))
			if err.Tool != "" {
				sb.WriteString(fmt.Sprintf("- **Tool:** %s\n", err.Tool))
			}
			sb.WriteString(fmt.Sprintf("- **Message:** `%s`\n\n", err.Message))
		}
	}

	// Event Log (condensed)
	sb.WriteString("## Event Timeline\n\n")
	sb.WriteString("<details>\n<summary>Click to expand event log</summary>\n\n")
	sb.WriteString("```\n")

	for _, event := range events {
		formatted := FormatEvent(event, false)
		sb.WriteString(formatted)
		sb.WriteString("\n")
	}

	sb.WriteString("```\n\n")
	sb.WriteString("</details>\n\n")

	// Footer
	sb.WriteString("---\n\n")
	sb.WriteString(fmt.Sprintf("*Generated by Pilot on %s*\n", time.Now().Format("2006-01-02 15:04:05")))

	return sb.String(), nil
}

// Helper functions

func formatDuration(d time.Duration) string {
	if d < time.Minute {
		return fmt.Sprintf("%.1fs", d.Seconds())
	}
	if d < time.Hour {
		m := int(d.Minutes())
		s := int(d.Seconds()) % 60
		return fmt.Sprintf("%dm %ds", m, s)
	}
	h := int(d.Hours())
	m := int(d.Minutes()) % 60
	return fmt.Sprintf("%dh %dm", h, m)
}

func formatNumber(n int64) string {
	if n < 1000 {
		return fmt.Sprintf("%d", n)
	}
	if n < 1000000 {
		return fmt.Sprintf("%.1fK", float64(n)/1000)
	}
	return fmt.Sprintf("%.1fM", float64(n)/1000000)
}
