import { Callout } from 'nextra/components'

# Autopilot Mode

Fully autonomous operation with automatic PR merging.

<Callout type="error" emoji="ğŸš¨">
  Autopilot can merge code without human review. Use with caution.
</Callout>

## Environments

| Environment | Auto-merge | CI Required | Use Case |
|-------------|------------|-------------|----------|
| `dev` | After CI passes | Yes | Personal projects |
| `stage` | After CI + delay | Yes | Team staging |
| `prod` | Never | Yes | Production (review required) |

See [Autopilot Environments](/features/autopilot-environments) for detailed behavior differences, recommended configurations, and migration guides.

## Configuration

```yaml
# ~/.pilot/config.yaml
autopilot:
  enabled: true
  environment: stage
  auto_merge: true
  require_ci: true
  merge_delay: 5m  # Wait before merging (stage only)
  protected_branches:
    - main
    - production
```

## Usage

```bash
# Development - fast iteration
pilot start --github --autopilot=dev

# Staging - with safety delay
pilot start --github --autopilot=stage

# Production - no auto-merge
pilot start --github --autopilot=prod
```

## Safety Features

### CI Requirement

Autopilot always waits for CI to pass:

```
Task â†’ PR â†’ CI Running â†’ CI Passes â†’ Merge
                      â†˜ CI Fails â†’ Notify, No Merge
```

### Merge Delay (Stage)

In `stage` mode, there's a configurable delay:

```
CI Passes â†’ 5min delay â†’ Check for comments â†’ Merge
                       â†˜ Comments found â†’ Notify, No Merge
```

### Protected Branches

Direct pushes to protected branches are blocked. Autopilot always creates PRs.

## Monitoring

Track autopilot activity:

```bash
# View recent autopilot actions
pilot logs --autopilot

# Dashboard with real-time updates
pilot start --github --autopilot=dev --dashboard
```

## Rollback

If autopilot merges something problematic:

```bash
# Revert the last autopilot merge
pilot rollback --last

# Revert a specific PR
pilot rollback --pr 123
```

## Conflict Resolution

When a Pilot PR has a merge conflict, autopilot automatically attempts to resolve it via rebase before falling back to full re-execution.

### Auto-Rebase Flow

```
Merge Conflict Detected
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Update Branch    â”‚ â† GitHub API rebase
â”‚ (auto-rebase)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚         â”‚
  Success   Failure
    â”‚         â”‚
    â–¼         â–¼
WaitingCI   Close PR
(re-run CI) (re-queue)
```

- **First attempt**: Uses GitHub's "Update branch" API â€” equivalent to clicking the "Update branch" button on the PR page
- **If rebase succeeds**: The PR returns to the `WaitingCI` stage and CI re-runs on the updated branch
- **If rebase fails**: The PR is closed with an explanatory comment, and the original issue returns to the queue for full re-execution from scratch
- **Cost savings**: Avoids ~$8â€“15 per full re-execution for conflicts that are trivially resolvable via rebase

## CI Fix Dependencies

When autopilot's feedback loop creates a CI fix issue (after a CI failure), the fix issue body includes a `Depends on: #N` annotation linking it back to the original parent issue. This provides traceability between fix attempts and the tasks that triggered them.

## Stagnation Monitor

Detects stuck executions by tracking state changes and escalating through progressive intervention levels.

### How Detection Works

Each execution turn, Pilot hashes the current state using the pattern `phase:progress:iteration`. This creates a unique fingerprint for each distinct execution state.

- **History buffer**: Recent state hashes are stored (configurable size, default 5)
- **Repeat detection**: Consecutive identical hashes indicate the execution is stuck in a loop
- **Time-based detection**: No progress for extended periods also triggers escalation

When either condition is met, the monitor escalates through intervention levels.

### Escalation Levels

| Level | Trigger | Action |
|-------|---------|--------|
| None | Normal progress | Continue execution |
| Warn | 3+ identical states OR `warn_timeout` (10m) | Log warning, continue |
| Pause | `pause_at_iteration` (12) OR `pause_timeout` (20m) | Pause execution, attempt recovery |
| Abort | `abort_at_iteration` (15) OR `abort_timeout` (30m) | Stop execution, optionally commit partial work |

### Configuration

```yaml
# ~/.pilot/config.yaml
executor:
  stagnation:
    enabled: true
    warn_timeout: 10m              # Time without progress before warning
    pause_timeout: 20m             # Time without progress before pause
    abort_timeout: 30m             # Time without progress before abort
    warn_at_iteration: 8           # Iteration count to trigger warn
    pause_at_iteration: 12         # Iteration count to trigger pause
    abort_at_iteration: 15         # Iteration count to trigger abort
    state_history_size: 5          # Number of state hashes to track
    identical_states_threshold: 3  # Consecutive identical states for warn
    grace_period: 30s              # Ignore stagnation during startup
    commit_partial_work: true      # Save progress on abort
```

### Partial Work Commit

When `commit_partial_work: true` (default), Pilot salvages progress on abort:

- Commits whatever changes were made before stagnation
- Creates a PR with partial implementation
- Marks the issue as `pilot-failed` with stagnation reason
- Allows manual continuation from the partial branch

<Callout type="warning">
The stagnation monitor is disabled by default. Enable it for long-running tasks where stuck executions waste tokens. The default timeouts (10m/20m/30m) work well for most projects.
</Callout>
