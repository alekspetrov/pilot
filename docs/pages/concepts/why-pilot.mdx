import { Callout } from 'nextra/components'

# Why Pilot

## The Shift: AI-Assisted â†’ AI-Autonomous

The AI development tools market has two distinct eras.

**Era 1: AI-Assisted (2021â€“2024).** Autocomplete, inline chat, code suggestions. You type, the AI predicts. GitHub Copilot, Cursor, Cody â€” all variations on the same idea: make the human faster at the keyboard. The human remains in the loop for every decision, every file change, every commit.

**Era 2: AI-Autonomous (2025â€“).** You define the work. The AI executes it end-to-end. Planning, implementation, testing, PR creation, CI monitoring, iteration. The human reviews the output â€” not every keystroke.

This isn't a theoretical shift. It's happening now.

```
Era 1: Human writes code â†’ AI suggests completions
Era 2: Human writes ticket â†’ AI ships the PR
```

Pilot is built for Era 2.

<Callout type="info">
This is not about replacing engineers. It's about removing engineers from work that doesn't need their judgment â€” CRUD endpoints, test coverage, documentation updates, bug fixes with clear repro steps.
</Callout>

The predictable, well-defined work that fills every backlog. The tickets your senior engineers don't want to pick up. The ones that are important but not interesting. That's Pilot's domain.

## The Problem With Current Tools

### Chatbots: constant prompting

ChatGPT, Claude chat, wrapper bots â€” they require you to describe what you want, review output, refine your prompt, review again. The feedback loop is faster than writing code manually, but you're still in the loop for every iteration. Token costs are unpredictable because conversations are open-ended. There's no memory between sessions.

### IDE agents: you at the keyboard

Cursor, GitHub Copilot, Windsurf â€” they make you faster *at the keyboard*. But you need to be at the keyboard. Context is limited to open files. The AI doesn't know your project's architecture, conventions, or SOPs. There's no cross-session memory and no autonomous execution.

### Cloud agents: black boxes

Devin, Factory, and similar cloud-based agents promise full autonomy. But your code runs on someone else's infrastructure. You can't inspect how decisions are made. Pricing is enterprise-only. The security model requires trusting a third party with your entire codebase and credentials.

### DIY Claude Code: no structure

Running Claude Code directly with a `CLAUDE.md` file works for one-off tasks. But there's no ticket integration, no CI feedback loop, no automatic PR creation, no model routing, and no cross-project memory. You're assembling the pipeline manually every time.

## Where Pilot Sits: The Positioning Quadrant

```
                       AUTONOMOUS
                           â†‘
                           â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                â”‚                â”‚
          â”‚   â— Pilot      â”‚    â— Devin     â”‚
          â”‚                â”‚    â— Factory   â”‚
          â”‚   Ticket in,   â”‚    Cloud agent â”‚
          â”‚   PR out.      â”‚    black box.  â”‚
          â”‚   Your infra.  â”‚    Their infra.â”‚
          â”‚                â”‚                â”‚
  SELF  â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€ CLOUD
 HOSTED   â”‚                â”‚                â”‚  HOSTED
          â”‚   â— DIY Claude â”‚    â— Cursor    â”‚
          â”‚     Code       â”‚    â— Copilot   â”‚
          â”‚                â”‚    â— Windsurf  â”‚
          â”‚   Manual       â”‚    Fast but    â”‚
          â”‚   assembly.    â”‚    manual.     â”‚
          â”‚                â”‚                â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â†“
                       ASSISTIVE
```

Pilot occupies a unique quadrant: **autonomous and self-hosted**. No other tool in the market combines ticket-driven autonomous execution with full self-hosting capability.

- **Top-left (Pilot):** Autonomous execution on your own infrastructure. Your code never leaves your environment. Full control over the AI pipeline.
- **Top-right (Devin, Factory):** Autonomous but cloud-locked. You trust a third party with source code access and CI credentials.
- **Bottom-right (Cursor, Copilot):** Assistive desktop/cloud tools. Fast for the human at the keyboard, but no autonomous execution.
- **Bottom-left (DIY Claude Code):** Self-hosted but manual. You get local execution without the automation layer.

## 5 Differentiators

### 1. Ticket-driven, not prompt-driven

You already write tickets for your team. Pilot reads the same tickets. No new workflow to learn. No prompt engineering. No special syntax. Write the ticket like you would for a junior developer, label it `pilot`, and the work gets done.

```
GitHub Issue â†’ Pilot picks it up â†’ PR appears â†’ You review
```

Supported sources: GitHub Issues, Linear, Jira, Asana. The ticket system is the interface because it's already where work gets defined.

### 2. Context intelligence: deep codebase understanding

This is Pilot's core differentiator. Pilot's built-in [context engine](/navigator) provides deep codebase understanding through strategic documentation loading. It reduces token usage by **92%** (from 150k to 12k tokens per session) while giving Pilot knowledge of your:

- **Architecture** â€” System design, data flows, component relationships
- **Patterns** â€” How you structure code, naming conventions, file organization
- **SOPs** â€” Standard operating procedures for common tasks
- **Cross-project memory** â€” Patterns learned across multiple repositories

Without context intelligence, AI generates generic code. With it, Pilot generates code that follows your established conventions. The difference between code that *works* and code that *belongs*.

### 3. Autopilot feedback loop

Most AI tools stop at code generation. Pilot manages the full PR lifecycle:

```
Ticket â†’ Plan â†’ Implement â†’ Self-Review â†’ Push â†’ PR â†’ CI
                                                      â”‚
                                                 CI passes?
                                                 â”œâ”€ Yes â†’ Auto-merge (stage/dev)
                                                 â”‚        or notify (prod)
                                                 â””â”€ No  â†’ Analyze failure
                                                          â†’ Fix on same branch
                                                          â†’ New PR â†’ CI again
```

Three environment modes control autonomy level:

| Mode | CI Wait | Auto-Merge | Use Case |
|------|---------|------------|----------|
| `dev` | Skip | Yes | Personal projects, fast iteration |
| `stage` | Required | Yes | Team staging, balanced safety |
| `prod` | Required | No (human approval) | Production, maximum control |

When CI fails, Pilot doesn't wait for human intervention. It reads the failure logs, creates a targeted fix on the original branch, and iterates until CI passes or the retry budget is exhausted.

### 4. Multi-mode Telegram interface

Pilot's Telegram bot isn't just a notification channel. It's a full development interface with five interaction modes:

| Mode | Trigger | Output |
|------|---------|--------|
| **Chat** | Conversational message | Discussion about your codebase |
| **Research** | "analyze", "investigate" | Deep analysis saved to project |
| **Planning** | "design", "plan" | Feature design with Execute/Cancel buttons |
| **Questions** | "what", "where", "how" | Quick read-only answers |
| **Tasks** | "add", "implement", "fix" | Full implementation with PR creation |

Intent is classified automatically. "What files handle authentication?" â†’ quick answer. "Add rate limiting to the API" â†’ task with confirmation. No mode switching required.

### 5. Complexity-aware model routing

Not every ticket needs the same level of AI reasoning. Pilot classifies ticket complexity and routes to the optimal model:

| Complexity | Model | Context | Cost | Example |
|------------|-------|-----------|------|---------|
| Trivial | Haiku (fast) | Skipped | ~$0.02 | Fix typo, rename variable |
| Simple | Opus 4.6 | Active | ~$0.50 | Add endpoint, write test |
| Medium | Opus 4.6 | Active | ~$1.50 | Feature spanning multiple files |
| Complex | Opus 4.6 (deep) | Active | ~$3.00 | Cross-cutting change |
| Epic | Opus 4.6 | Active | ~$5.00+ | Auto-decomposed into subtasks |

Trivial tickets cost cents and complete in seconds. Complex tickets get the reasoning depth they need. Budget limits prevent runaway costs.

## Feature Comparison

| Capability | Pilot | Cursor | Copilot | Devin | DIY Claude Code |
|-----------|-------|--------|---------|-------|-----------------|
| **Autonomous execution** | âœ… Ticket â†’ PR | âŒ | âŒ | âœ… | âš ï¸ Manual |
| **Ticket integration** | âœ… GitHub, Linear, Jira, Asana | âŒ | âš ï¸ Partial | âœ… | âŒ |
| **Codebase context** | âœ… Built-in (deep) | âš ï¸ File-level | âš ï¸ File-level | âš ï¸ Proprietary | âš ï¸ Manual CLAUDE.md |
| **Cross-project memory** | âœ… | âŒ | âŒ | â“ Unknown | âŒ |
| **Self-hosted** | âœ… Your machine | âš ï¸ Desktop app | âŒ Cloud | âŒ Cloud | âœ… |
| **Source-available** | âœ… BSL 1.1 | âŒ | âŒ | âŒ | N/A |
| **PR creation** | âœ… Automatic | âŒ | âš ï¸ Workspace beta | âœ… | âš ï¸ Manual |
| **CI feedback loop** | âœ… Auto-fix on failure | âŒ | âŒ | âŒ | âŒ |
| **Model routing** | âœ… Haiku + Opus | âŒ Fixed | âŒ Fixed | âŒ Fixed | âš ï¸ Manual |
| **Cost control** | âœ… Budget limits | ğŸ’° Per-seat | ğŸ’° Per-seat | ğŸ’° Per-seat | âš ï¸ Manual |
| **Telegram interface** | âœ… 5 modes | âŒ | âŒ | âŒ | âŒ |
| **Epic decomposition** | âœ… Auto-splits | âŒ | âŒ | âš ï¸ Limited | âŒ |

## What Pilot Is Not

<Callout type="warning">
Pilot augments engineers. It does not replace them. Understanding the boundaries is as important as understanding the capabilities.
</Callout>

### Not an architect

Pilot executes well-defined work. It doesn't make architectural tradeoffs, choose between database designs, or decide on authentication strategies. Those decisions require engineering judgment, business context, and experience with production consequences. Use the context engine to plan. Use Pilot to execute the plan.

### Not a researcher

If the task requires exploring unknown solution spaces, experimenting with novel algorithms, or making creative leaps â€” that's human work. Pilot works best when the pattern is established and the implementation is bounded. It excels at applying known patterns, not discovering new ones.

### Not a security auditor

Authentication flows, encryption, access control â€” these need careful human review regardless of who writes them. Pilot can write tests for security code and implement well-documented security patterns, but shouldn't be the sole author of security-critical logic. Always review security-adjacent PRs with extra scrutiny.

### Not a silver bullet

Pilot handles roughly **60% of tickets** â€” the ones that are predictable, well-defined, and follow established patterns. The other 40% still need your team: architecture decisions, complex debugging, user research, product design, novel integrations.

The value isn't in handling 100% of work. It's in freeing your engineers to focus on the 40% that actually requires their expertise, judgment, and creativity.

### Not a replacement for code review

Every Pilot PR goes through the same review process as any team member's PR. The `prod` environment mode enforces human approval before merge. Pilot writes code; humans verify it meets standards.

## The Vision

```
Today:   Engineer â†’ reads ticket â†’ opens IDE â†’ writes code â†’ tests â†’ PR â†’ reviews CI â†’ merges
         (2-8 hours per ticket)

Pilot:   Engineer â†’ writes ticket â†’ labels "pilot" â†’ reviews PR â†’ merges
         (5 minutes of engineer time per ticket)
```

Software development has a massive efficiency problem. Engineers spend significant time on work that is well-defined, bounded, and follows established patterns. This work is important â€” it keeps products running, users happy, and backlogs manageable â€” but it doesn't require creative problem-solving.

Pilot's vision: handle predictable work automatically, at the same quality bar your team maintains, while keeping engineers in control through PR review. The ticket is the interface because it's where work is already defined. The PR is the output because it's where code is already reviewed.

No new tools to learn. No new workflows to adopt. Label a ticket, review a PR. That's it.
