import { Callout, Steps, Tabs } from 'nextra/components'

# Quick Start: First PR in 10 Minutes

This guide takes you from zero to your first AI-generated pull request.

<Callout type="info">
**Before you start:** Complete the [Prerequisites](/getting-started/prerequisites) — Claude Code installed and authenticated, Git hosting token set.
</Callout>

{/* ILLUSTRATION: First PR flow — issue created → Pilot picks up → PR appears */}

<Steps>

### Install Pilot

<Tabs items={['Quick Install (recommended)', 'Homebrew', 'From Source']}>
  <Tabs.Tab>
```bash
curl -fsSL https://raw.githubusercontent.com/alekspetrov/pilot/main/install.sh | bash
```
  </Tabs.Tab>
  <Tabs.Tab>
```bash
brew tap alekspetrov/pilot && brew install pilot
```
  </Tabs.Tab>
  <Tabs.Tab>
```bash
git clone https://github.com/alekspetrov/pilot
cd pilot && make build
cp ./bin/pilot ~/.local/bin/pilot
```
  </Tabs.Tab>
</Tabs>

Verify:

```bash
pilot --version
# pilot version v0.23.3
```

### Run the Setup Wizard

```bash
pilot setup
```

The wizard walks you through:
- Selecting your default project path
- Configuring Telegram bot (optional)
- Setting up notification preferences

This creates `~/.pilot/config.yaml`. You can edit it manually later — see [Configuration](/getting-started/configuration) for all options.

### Configure Your Repository

<Tabs items={['GitHub', 'GitLab']}>
  <Tabs.Tab>
Add your GitHub repository to `~/.pilot/config.yaml`:

```yaml
adapters:
  github:
    enabled: true
    token: ${GITHUB_TOKEN}
    repo: "your-username/your-repo"
    project_path: "~/Projects/your-repo"
    pilot_label: "pilot"
    polling:
      enabled: true
      interval: 30s
```

Make sure your token is set:

```bash
export GITHUB_TOKEN="your-github-pat"
```
  </Tabs.Tab>
  <Tabs.Tab>
Add your GitLab repository to `~/.pilot/config.yaml`:

```yaml
adapters:
  gitlab:
    enabled: true
    token: ${GITLAB_TOKEN}
    base_url: "https://gitlab.com"       # or your self-hosted URL
    project: "your-namespace/your-repo"
    project_path: "~/Projects/your-repo"
    pilot_label: "pilot"
    polling:
      enabled: true
      interval: 30s
```

Make sure your token is set:

```bash
export GITLAB_TOKEN="your-gitlab-pat"
```
  </Tabs.Tab>
</Tabs>

### Start Pilot

<Tabs items={['GitHub', 'GitLab']}>
  <Tabs.Tab>
```bash
pilot start --github --dashboard
```
  </Tabs.Tab>
  <Tabs.Tab>
```bash
pilot start --gitlab --dashboard
```
  </Tabs.Tab>
</Tabs>

The dashboard appears, showing Pilot is polling for issues:

```
┌─ PILOT ─────────────────────────────────────────┐
│  Status: Running    Mode: Polling                │
│  Queue: 0 tasks     Uptime: 12s                  │
│                                                   │
│  Waiting for issues labeled "pilot"...            │
└───────────────────────────────────────────────────┘
```

{/* ILLUSTRATION: Dashboard screenshot — waiting state */}

### Create Your First Issue

Open a new terminal and create an issue with the `pilot` label:

<Tabs items={['GitHub (gh CLI)', 'GitHub (Web)', 'GitLab']}>
  <Tabs.Tab>
```bash
gh issue create \
  --title "Add health check endpoint" \
  --label pilot \
  --body "Create a GET /health endpoint that returns JSON with status: ok and the current server timestamp. Add a test."
```
  </Tabs.Tab>
  <Tabs.Tab>
    Go to your repository → **Issues** → **New Issue**.
    Set **Title** to `Add health check endpoint`,
    add the `pilot` label (create it first if it doesn't exist),
    and set **Body** to: `Create a GET /health endpoint that returns JSON with status: ok and the current server timestamp. Add a test.`
  </Tabs.Tab>
  <Tabs.Tab>
    Go to your project → **Issues** → **New Issue**.
    Set **Title** to `Add health check endpoint`,
    add the `pilot` label (create it first if it doesn't exist),
    and set **Description** to: `Create a GET /health endpoint that returns JSON with status: ok and the current server timestamp. Add a test.`

    Or use the GitLab API:

    ```bash
    curl --request POST \
      --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
      --header "Content-Type: application/json" \
      --data '{"title": "Add health check endpoint", "labels": "pilot", "description": "Create a GET /health endpoint..."}' \
      "https://gitlab.com/api/v4/projects/YOUR_PROJECT_ID/issues"
    ```
  </Tabs.Tab>
</Tabs>

### Watch Pilot Work

Within 30 seconds, Pilot detects the issue and starts executing. The dashboard updates in real-time:

```
⏳ Processing: Add health check endpoint

   Implementing   [████████████░░░░░░░░] 60%  GH-12  32s

   [14:35:15] Started Navigator session
   [14:35:18] Analyzing codebase patterns...
   [14:35:25] Creating health endpoint
   [14:35:40] Adding route
   [14:35:55] Writing tests...

✅ PR created: github.com/you/your-repo/pull/13
```

{/* ILLUSTRATION: Dashboard screenshot — task executing with progress */}

</Steps>

## Review and Merge

Pilot creates a PR with:
- Implementation following your existing codebase patterns
- Tests matching your test structure
- A PR description linking back to the issue

<Tabs items={['GitHub', 'GitLab']}>
  <Tabs.Tab>
```bash
# Review the PR
gh pr view 13
gh pr diff 13

# Merge when satisfied
gh pr merge 13
```
  </Tabs.Tab>
  <Tabs.Tab>
Review the merge request in the GitLab UI, or:
```bash
# Using glab CLI
glab mr view 13
glab mr merge 13
```
  </Tabs.Tab>
</Tabs>

<Callout type="info">
With `--autopilot=stage`, Pilot monitors CI automatically and merges once tests pass — no manual merge needed. See [Autopilot](/features/autopilot).
</Callout>

---

## Starter Tickets

Well-scoped tasks that work reliably as first tickets:

| Ticket | Why It Works |
|--------|-------------|
| "Add health check endpoint" | Simple, bounded, easy to verify |
| "Write tests for UserService" | Clear scope, follows existing test patterns |
| "Add loading spinner to Button component" | Small UI change with clear output |
| "Update README with setup instructions" | Documentation, low risk |
| "Add input validation to create endpoint" | Well-defined rules, testable |

<Callout type="warning">
**Avoid for first tickets:** Architecture changes, multi-service refactors, or tasks requiring design decisions. Start with bounded, well-defined work.
</Callout>

## What Just Happened?

Here's the execution flow Pilot followed:

1. **Polling** — Pilot detected the new issue with the `pilot` label
2. **Branching** — Created a working branch (`pilot/GH-12` or `pilot/add-health-check`)
3. **Navigator** — Loaded your project context from `.agent/` (if initialized) for pattern awareness
4. **Execution** — Claude Code analyzed your codebase and implemented the change
5. **Quality Gates** — Ran build/test/lint checks (auto-detected or configured)
6. **Self-Review** — Claude Code reviewed its own changes for quality
7. **PR** — Pushed the branch and created a pull request

## Next Steps

- [Configuration](/getting-started/configuration) — Tune all config.yaml options
- [Autopilot](/features/autopilot) — Automatic CI monitoring and merge
- [Telegram Bot](/features/telegram) — Chat, research, plan, and execute from mobile
- [Navigator](/navigator) — Reduce token usage by 92% with structured context
- [Hot Upgrade](/features/hot-upgrade) — Keep Pilot updated without downtime
